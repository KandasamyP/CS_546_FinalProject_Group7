const mongoCollections = require("../config/mongoCollections");
const { ObjectId } = require("mongodb").ObjectId;
const bcrypt = require("bcrypt");
const saltRounds = 16;
const petOwnerData = mongoCollections.petOwner;
const shelterAndRescueData = mongoCollections.shelterAndRescue;
const petData = mongoCollections.pets;
const zipcodes = require("zipcodes");


//Check if user is volunteer
async function checkVolunteer(emailID) {
  try {
    if (emailID === undefined || emailID.trim() === "") {
      throw "Email ID Not passed";
    }
  } catch (e) {
    throw e;
  }

  try {
    const petOwnerCollection = await petOwnerData();

    let petOwnerDetails = await petOwnerCollection.findOne({
      email: emailID,
    });
    return petOwnerDetails.isVolunteerCandidate;
  } catch (e) {
    throw "Cannot check if volunteer";
  }
}


//validates email
function validateEmail(email) {
  const re =
    /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
  return re.test(String(email).toLowerCase());
}

//returns a petOwner user searches by petOwner Email/Username
async function getPetOwnerByUserEmail(petOwnerEmail) {
  //check email
  try{
      if (petOwnerEmail === undefined || petOwnerEmail.trim() === ""){
        throw {
          status: 400,
          error: "Email must be provided. Generated by /data/petOwner/getPetOwnerByUserEmail",
        }
      }


       if (!validateEmail(petOwnerEmail)) {
        throw {
          status: 400,
          error:
            "E-Mail not in correct format. Generated by /data/petOwner/getPetOwnerByUserEmail",
        };
      }

      const petOwnerCollection = await petOwnerData();

      let petOwnerDetails = await petOwnerCollection.findOne({ email: petOwnerEmail });
    
      if (petOwnerDetails == null || !petOwnerDetails) throw {status:404, error: "petOwner/adopter User not found. Generated by /data/petOwner/getPetOwnerByUserEmail"};
    
      // return _id as string
      petOwnerDetails._id = petOwnerDetails._id.toString();
    
      return petOwnerDetails;
  }catch(e){
    throw { status: e.status, error:e.error}
  }
}

// return a petOwner searches by pet Owner id
async function getPetOwnerById(petOwnerId) {
   //checking petOwnerId
  try{
    if (!petOwnerId) {
      throw {
        status: 400,
        error: "Missing petOwner/adopter id. Generated by data/petOwner/getPetOwnerById",
      }
    }
    if (!ObjectId.isValid(petOwnerId)) {

      throw {
        status: 400,
        error: "Invalid petOwner/adopter id. Generated by data/petOwner/getPetOwnerById",
      }
    }

    const petOwnerCollection = await petOwnerData();

    const petOwnerDetails = await petOwnerCollection.findOne({
      _id: ObjectId(petOwnerId),
    });
  
    if (petOwnerDetails == null || !petOwnerDetails) throw {status:404, error: "petOwner/adopter not found. Generated by data/petOwner/getPetOwnerById"};
  
    return petOwnerDetails;
  }catch(e){
    throw { status: e.status, error: e.error}
  }
 
}

//returns updated petOwner data
async function updatePetOwner(updatedData) {
  try{

    if(updatedData.biography){
        if(typeof updatedData.biography !== "string"){
          throw {status: 400, error: "Biography is not a string. Generated by data/petOwner/updatePetOwner"}
        }
    }

    if(updatedData.fullName){
      if(updatedData.fullName.hasOwnProperty("firstName") && typeof updatedData.fullName.firstName !== "string"){
          throw {status:400,error: "firstname is not a string. Generated by data/petOwner/updatePetOwner"}
      }
    }

    if(updatedData.fullName){
      if(updatedData.fullName.hasOwnProperty("lastName") && typeof updatedData.fullName.lastName !== "string"){
          throw {status:400,error: "firstname is not a string. Generated by data/petOwner/updatePetOwner"}
      }
    }

    if (updatedData.zipCode){
      if (zipcodes.lookup(updatedData.zipCode) === undefined) {
        throw {status : 400, error: "Invalid zip code . Generated by data/petOwner/updatePetOwner "}
      }
    }

    const phoneNumberRegex = /^[\+]?[(]?[0-9]{3}[)]?[-\s\.]?[0-9]{3}[-\s\.]?[0-9]{4,6}$/im;  //regex to check phone Number

    if (updatedData.phoneNumber){
      if(!phoneNumberRegex.test(updatedData.phoneNumber)){
        throw {status : 400, error: "Invalid phone number . Generated by data/petOwner/updatePetOwner "}
      }
    }

    function dateChecker(date1, date2 = new Date()) {
      var date1 = new Date(Date.parse(date1));
      var date2 = new Date(Date.parse(date2));
      var ageTime = date2.getTime() - date1.getTime();
  
      if (ageTime < 0) {
        return false; //date2 is before date1
      } else {
        return true;
      }
    }

    if (updatedData.dateOfBirth){
      if (!dateChecker(updatedData.dateOfBirth)) {
        throw {status : 400, error: "Date can not be a future date. Generated by data/petOwner/updatePetOwner."}
      }
    }

    let modifiedData = {
      fullName: {
        firstName: String,
        lastName: String,
      },
      phoneNumber: Number,
      zipCode: String,
      biography: String,
      dateOfBirth: String,
    };
  
    //check updatedData fields
    let existingUserData = await getPetOwnerByUserEmail(updatedData.email);
    // console.log("existing data");
    // console.log(existingUserData);
  
    if (updatedData.fullName) {
      if (
        updatedData.fullName.hasOwnProperty("firstName") &&
        updatedData.fullName.firstName.trim() != ""
      ) {
        // modifiedData.fullName = {firstName : updatedData.fullName.firstName};
        modifiedData.fullName["firstName"] = updatedData.fullName.firstName;
      } else {
        //modifiedData.fullName = {firstName : existingUserData.fullName.firstName};
        modifiedData.fullName["firstName"] = existingUserData.fullName.firstName;
      }
      if (
        updatedData.fullName.hasOwnProperty("lastName") &&
        updatedData.fullName.lastName.trim() != ""
      ) {
        // modifiedData.fullName = {lastName : updatedData.fullName.lastName};
        modifiedData.fullName["lastName"] = updatedData.fullName.lastName;
      } else {
        //modifiedData.fullName = {lastName : existingUserData.fullName.lastName};
        modifiedData.fullName["lastName"] = existingUserData.fullName.lastName;
      }
    } else {
      modifiedData.fullName = existingUserData.fullName;
    }
  
    if (updatedData.phoneNumber) {
      modifiedData.phoneNumber = updatedData.phoneNumber;
    } else {
      modifiedData.phoneNumber = existingUserData.phoneNumber;
    }
  
    if (updatedData.zipCode) {
      modifiedData.zipCode = updatedData.zipCode;
    } else {
      modifiedData.zipCode = existingUserData.zipCode;
    }
  
    if (updatedData.biography) {
      modifiedData.biography = updatedData.biography;
    } else {
      modifiedData.biography = existingUserData.biography;
    }
    if (updatedData.dateOfBirth) {
      modifiedData.dateOfBirth = updatedData.dateOfBirth;
    } else {
      modifiedData.dateOfBirth = existingUserData.dateOfBirth;
    }
  
    const petOwnerCollection = await petOwnerData();
  
    const updateInfo = await petOwnerCollection.updateOne(
      { _id: ObjectId(existingUserData._id) },
      { $set: modifiedData }
    );
    if (updateInfo.matchedCount === 0 && updateInfo.modifiedCount === 0)
        throw {status : 500, error: "Could not update petOwner/Adopter. Generated by data/petOwner/updatePetOwner "}
  
    // console.log(await getPetOwnerById(existingUserData._id));
    return await getPetOwnerById(existingUserData._id);
  
  }catch(e){
    throw {status: e.status, error: e.error}
  }
  }

async function updatePetOwnerFeedbackById(req) {
  try{
    if (!req){
      throw {status:400, error: "req missing. Generated by /data/petOwner/updatePetOwnerFeedbackById"};
    }
    const petOwnerCollection = await petOwnerData();
    let petOwner = await this.getPetOwnerByUserEmail(req.session.user.email);

    const addFeedback = {
      date: new Date(),
      rating: req.body.rating,
      feedback: req.body.experience,
      feedbackGivenBy: petOwner._id
    };
    addFeedback._id = ObjectId();

    petOwner.websiteFeedbackGiven.push(addFeedback);

    petOwner._id = ObjectId(petOwner._id);

    const updateInfo = await petOwnerCollection.updateOne({ _id: ObjectId(petOwner._id) }, { $set: petOwner });
    if (updateInfo.modifiedCount === 0)
      throw {status:500, error: "Not able to update db.Generated by /data/petOwner/updatePetOwnerFeedbackById"};
  }catch(e){
      throw {status:e.status, error: e.error};
  }

}

async function updatePassword(userId, plainTextPassword) {
  try{
       //check for type of ID and password
        if (!userId) {
          throw {status: 400, error: "User id must be provided. Generated by data/petOwner/updatePassword" };
        }
        if (!ObjectId.isValid(userId)) {
          throw {
            status: 400,
            error: "Invalid petOwner/adopter id. Generated by Generated by data/petOwner/updatePassword",
          }
        }
        if (!plainTextPassword) {
          throw {status: 400, error: "password must be provided.Generated by data/petOwner/updatePassword" };
        }

        if (plainTextPassword.trim().length < 6) {
          throw {status: 400, error: "Password must contain at least 6 characters. Generated by data/petOwner/updatePassword" };
        }

        const hashedPassword = await bcrypt.hash(plainTextPassword, saltRounds);
        const petOwnerCollection = await petOwnerData();

        const updateInfo = await petOwnerCollection.updateOne(
          { _id: ObjectId(userId) },
          { $set: { "password": hashedPassword } }
        );

        if (updateInfo.matchedCount === 0 && updateInfo.modifiedCount === 0)
          throw {status: 500, error: "Could not update password.Generated by data/petOwner/updatePassword"};

        return await getPetOwnerById(userId);
  }catch(e){
      throw {status:e.status, error: e.error};
  }

}

//this function updates the profile picture
async function updateProfileImage(email, picture) {

  try{
    if (email === undefined || email.trim() === ""){
      throw {
        status: 400,
        error: "Email must be provided. Generated by /data/petOwner/updateProfileImage",
      }
    }

     if (!validateEmail(email)) {
      throw {
        status: 400,
        error:
          "E-Mail not in correct format. Generated by /data/petOwner/updateProfileImage",
      };
    }
    if (!picture || picture.trim() === "") throw {
      status: 400,
      error:
        "profile picture must be provided. Generated by /data/petOwner/updateProfileImage",
    };

    const userDetails = await getPetOwnerByUserEmail(email);

    const petOwnerCollection = await petOwnerData();
    const updateInfo = await petOwnerCollection.updateOne(
      { _id: ObjectId(userDetails._id) },
      { $set: { "profilePicture": picture } }
    );
  
    if (updateInfo.matchedCount === 0 && updateInfo.modifiedCount === 0)
      throw {status:500, error:"Could not update profile picture.Generated by /data/petOwner/updateProfileImage "}
  
    return await getPetOwnerById(ObjectId(userDetails._id));

  }catch(e){
    throw{status:e.status, error:e.error};
  } 

}

//this function returns the shelter reviews given by user
async function getShelterReviews(userId) {

  try{

    if (!userId) {
      throw {status: 400, error: "User id must be provided. Generated by data/petOwner/getShelterReviews" };
    }
    if (!ObjectId.isValid(userId)) {
      throw {
        status: 400,
        error: "Invalid petOwner/adopter id. Generated by Generated by data/petOwner/getShelterReviews",
      }
    }
     
      let userDetails = await getPetOwnerById(ObjectId(userId));
      
      let shelterReviewsArray = userDetails.shelterReviewsGiven;

        const shelterAndRescueCollection = await shelterAndRescueData();
        let shelterReviewArray = [];
      for (let index = 0; index < shelterReviewsArray.length; index++){
       
        // console.log(shelterReviewsArray[index]);
        const shelterReviewDetails = await shelterAndRescueCollection.findOne({ "reviews._id": shelterReviewsArray[index]}, { projection: {_id:0, reviews:1, name:1}});
      
        // console.log(shelterReviewDetails.name);
        // console.log(shelterReviewDetails.reviews);
        
         for (let reviewIndex = 0; reviewIndex < shelterReviewDetails.reviews.length; reviewIndex++) {
              if (shelterReviewDetails.reviews[reviewIndex].reviewer == userId){
                shelterReviewArray.push({
                  name: shelterReviewDetails.name,
                  reviews: shelterReviewDetails.reviews[reviewIndex]
                })
              }
          }

      }

      // for (let index = 0; index < shelterReviewArray.length; index++)
      //   console.log(shelterReviewArray[index]);
    
      return shelterReviewArray;
  }catch(e){
    throw {status:e.status, error:e.error}
  }
}

async function getUserFavoritePets(favoritePetArray) {
  try{
    if (!Array.isArray(favoritePetArray)) throw {status:400, error:"favoritePets must be an array generated by data/petOwner/getUserFavoritePets"};
      const petCollection = await petData();
      let favoritePetsDetails = [];
      for (let i = 0; i < favoritePetArray.length; i++) {

        const petDetails = await petCollection.findOne({ _id: ObjectId(favoritePetArray[i]) });
        if (petDetails == null) throw {status:500, error:"pet not found. generated by data/petOwner/getUserFavoritePets"};
        favoritePetsDetails.push({
          id: petDetails._id,
          name: petDetails.petName,
          image: petDetails.petPictures[0]
        });
      }
      // for (let index = 0; index < favoritePetsDetails.length; index++)
      //   console.log(favoritePetsDetails[index]);
      return favoritePetsDetails;
  }catch(e){
    throw {status:e.status, error: e.error};
  } 
}

async function updateVolunteerStatus(userId, status) {

  try{  
    if (!userId) {
      throw {status: 400, error: "User id must be provided. Generated by data/petOwner/updateVolunteerStatus" };
    }
    if (!ObjectId.isValid(userId)) {
      throw {
        status: 400,
        error: "Invalid petOwner/adopter id. Generated by Generated by data/petOwner/updateVolunteerStatus",
      }
    }
    if (!status || status.trim() == "") {
      throw {status: 400, error: "status must be provided.Generated by data/petOwner/updateVolunteerStatus" };
    }

      let value = Boolean;
      //console.log(userId+" "+status);
      if (status == "true")
        value = true;
      else
        value = false;
      const petOwnerCollection = await petOwnerData();


      const updateInfo = await petOwnerCollection.updateOne(
        { _id: ObjectId(userId) },
        { $set: { "isVolunteerCandidate": value } }
      );


      if (updateInfo.matchedCount === 0 && updateInfo.modifiedCount === 0)
        throw {status: 500, error: " Could not update password. generated by /data/petOwner/updateVolunteerStatus"}

      return await getPetOwnerById(userId);
  }catch(e){
    throw{status:e.status, error:e.error};
  }
}

async function getPetCount() {
  try{
    const shelterAndRescueCollection = await shelterAndRescueData();

    const shelterData = await shelterAndRescueCollection.find({}).toArray();
  
    if (shelterData == null) throw { status:404, error: "shelter data does not exist. generated by /data/petOwner/getPetCount"};
    let total = 0
    for (let i = 0; i < shelterData.length; i++) {
      total += shelterData[i].adoptedPets.length;
    }
    return total;
  }catch(e){
    throw {status: e.status, error: e.error}

  }
}

async function getAllUsersWithFavoritePet(id) {
  try{
    if (!id) throw {status:400, error: "The input id is missing. generated by /data/petOwner/getAllUsersWithFavoritePet"};
    // If the id provided is not a string, or is an  empty string, the method should throw
    if (typeof id !== "string") throw {status:400, error: "The input must be a string. generated by /data/petOwner/getAllUsersWithFavoritePet"};
    if (id.trim().length === 0) throw {status:400, error: "The input must not be empty. generated by /data/petOwner/getAllUsersWithFavoritePet"};
    // If the id provided is not a valid ObjectId, the method should throw
    // if it cannot be converted to ObjectId, it will automatically throw an error
    let parsedId = ObjectId(id);

    const userCollection = await petOwnerData();
    let userResults = await userCollection.find({ favoritedPets: id }).toArray();
    let userIds = [];

    for (let user of userResults) {
      userIds.push(user._id.toString());
    }

    return userIds;
  }catch(e){
    throw {status:e.status, error:e.error}
  }
}

async function updateShelterReviewsGiven(petOwnerId, reviewId) {
  try{  
    if (!petOwnerId || !reviewId) {
      throw {status: 400, error: "User id must be provided. Generated by data/petOwner/updateShelterReviewsGiven" };
    }
    if (!ObjectId.isValid(petOwnerId) || !ObjectId.isValid(reviewId)) {
      throw {
        status: 400,
        error: "Invalid petOwner/adopter id. Generated by Generated by data/petOwner/updateShelterReviewsGiven",
      }
    }

      const petOwnerCollection = await petOwnerData();
      const petOwnerDetails = await getPetOwnerById(petOwnerId);
      petOwnerDetails.shelterReviewsGiven.push(reviewId);
    
      const updateInfo = await petOwnerCollection.updateOne(
        { _id: petOwnerId },
        { $set: petOwnerDetails }
      );

      return await getPetOwnerById(petOwnerId);
  }catch(e){
    throw{status:e.status, error:e.error};
  }
}

module.exports = {
  getPetOwnerById,
  updatePetOwner,
  getPetOwnerByUserEmail,
  updatePetOwnerFeedbackById,
  updatePassword,
  getShelterReviews,
  updateProfileImage,
  getUserFavoritePets,
  checkVolunteer,
  updateVolunteerStatus,
  getPetCount,
  updateShelterReviewsGiven,
  getAllUsersWithFavoritePet,

};
